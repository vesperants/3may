#!/usr/bin/env python3
"""
Send <message> on behalf of <user_id>.
Session IDs auto‑generated by Vertex AI are cached in session_map.json.
stdout: reply text
"""
import sys, os, json, logging, pathlib
from dotenv import load_dotenv
from google.adk.agents   import Agent
from google.adk.runners  import Runner
from google.adk.sessions import VertexAiSessionService
from google.genai        import types
from google.genai.errors import ClientError

# ── logging ─────────────────────────────────────────────────
logging.basicConfig(level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s", stream=sys.stderr)
log = logging.getLogger(__name__)
# ────────────────────────────────────────────────────────────

load_dotenv()
PROJ = os.getenv("GOOGLE_CLOUD_PROJECT_ID")
LOC  = os.getenv("GOOGLE_CLOUD_LOCATION", "us-central1")
APP  = os.getenv("VERTEX_SESSION_APP_NAME")
MAP  = pathlib.Path(__file__).with_name("session_map.json")

if not PROJ or not APP:
    print("❌ env error"); sys.exit(1)

agent = Agent(model="gemini-2.0-flash",
              name="conversational_agent",
              instruction="You are a helpful, concise assistant.")
svc   = VertexAiSessionService(project=PROJ, location=LOC)
runner = Runner(agent=agent, app_name=APP, session_service=svc)

def load_map():
    if MAP.exists():
        try: return json.loads(MAP.read_text())
        except Exception: pass
    return {}

def save_map(m): MAP.write_text(json.dumps(m))

def cached_session(uid: str):
    cache = load_map()
    sid = cache.get(uid)
    if sid:
        try:
            return svc.get_session(app_name=APP, user_id=uid, session_id=sid)
        except ClientError as e:
            log.warning(f"Invalid cached session {sid} (code={e.code})")
    sess = svc.create_session(app_name=APP, user_id=uid)
    sid_new = getattr(sess, "id", None) or sess.get("id")
    if not sid_new:
        raise RuntimeError("create_session() returned object w/o 'id'")
    cache[uid] = sid_new; save_map(cache)
    log.info(f"Cached new session id {sid_new}")
    return sess

def chat(uid: str, msg: str) -> str:
    sess = cached_session(uid)
    sid  = load_map()[uid]  # numeric ID now guaranteed
    content = types.Content(role="user", parts=[types.Part(text=msg)])
    reply = "Agent did not reply."
    for ev in runner.run(user_id=uid, session_id=sid, new_message=content):
        if (ev.is_final_response() and ev.author==agent.name and
                ev.content and ev.content.parts):
            reply = ev.content.parts[0].text; break
    return reply

# ── main ────────────────────────────────────────────────────
if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("❌ need <user_id> <message>"); sys.exit(1)
    uid = sys.argv[1]                    # 2nd arg (old sessionId) ignored
    message = " ".join(sys.argv[2:]) or "(empty)"
    try:    print(chat(uid, message))
    except Exception as e:
        log.exception(e); print("❌ error"); sys.exit(1)